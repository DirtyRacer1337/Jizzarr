<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Collection</title>
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.6.1/toastify.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='collection.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="custom-navbar">
        <a href="{{ url_for('index') }}">
            <img src="{{ url_for('static', filename='favicon.ico') }}" alt="Favicon" class="favicon">
            Jizzarr Home
        </a>
        <a href="{{ url_for('collection') }}">My Collection</a>
        <a href="{{ url_for('config_page') }}">Settings</a>
        <a href="{{ url_for('logs') }}">Logs</a>
        <a href="{{ url_for('stats_page') }}">Stats</a>
    </nav>
    <div class="container mt-4">
        <div class="mb-3">
            <input type="text" id="search-input" class="form-control" placeholder="Search by site name...">
        </div>
        <div class="d-flex justify-content-between mb-3">
            <button id="sort-asc" class="btn btn-secondary">Sort A-Z</button>
            <button id="sort-desc" class="btn btn-secondary">Sort Z-A</button>
        </div>
        <div class="pagination-controls d-flex justify-content-center mt-4">
            <button id="site-first-page" class="btn btn-outline-secondary me-2">First</button>
            <button id="site-prev-page" class="btn btn-outline-secondary me-2">Prev</button>
            <button id="site-next-page" class="btn btn-outline-secondary me-2">Next</button>
            <button id="site-last-page" class="btn btn-outline-secondary">Last</button>
        </div>
        <div id="site-collection" class="row g-4"></div>
        <div id="scene-collection" class="d-none">
            <div id="back-button-container" class="mb-3">
                <button id="back-button" class="btn btn-secondary">Back to Sites</button>
            </div>
            <div class="site-logo" id="site-logo"></div>
            <p class="site-title" id="site-title"></p>
            <div class="scene-count" id="scene-count"></div>
            <div class="match-controls">
                <div>
                    <label for="page-size">Results per page:</label>
                    <select id="page-size" class="form-select w-auto d-inline-block">
                        <option value="10">10</option>
                        <option value="25">25</option>
                        <option value="50">50</option>
                        <option value="100" selected>100</option>
                    </select>
                </div>
                <button id="toggle-matches" class="btn btn-primary">Show Only Matched Scenes</button>
                <button id="set-home-directory-button" class="btn btn-primary">Set Home Directory</button>
                <button id="suggest-matches-button" class="btn btn-primary">Suggest Matches</button>
                <button id="match-by-uuid-button" class="btn btn-primary">Match by UUID</button>
                <button id="bulk-update-button" class="btn btn-primary">Bulk Update Matches</button>
                <button id="search-stash-button" class="btn btn-primary">Search Stash for Matches</button>
                <button id="get-all-urls-button" class="btn btn-primary" data-state="start">
                <i class="fa fa-play"></i> Get All Scene URLs
                </button>
            </div>
            <div id="compare-container" class="compare-container mt-3">
                <h4>Current Home Directory:</h4>
                <h5><span id="home-directory-display"></span></h5>
            </div>
            <div class="mb-3">
                <input type="text" id="performer-search-input" class="form-control" placeholder="Search by performer name...">
            </div>      
            <table class="table table-dark-mode">
                <thead>
                    <tr>
                        <th data-column="title">Title</th>
                        <th data-column="date">Release Date</th>
                        <th data-column="duration">Duration</th>
                        <th data-column="performers">Performers</th>
                        <th data-column="status">Status</th>
                        <th data-column="file_path">File Directory</th>
                        <th data-column="foreign_guid">TPDB Scene UUID</th>
                        <th>Action</th>
                        <th>Scene URL</th>
                    </tr>
                </thead>
                <tbody id="scene-table-body"></tbody>
            </table>
            <div class="pagination-controls d-flex justify-content-center mt-4">
                <button id="scene-first-page" class="btn btn-outline-secondary me-2">First</button>
                <button id="scene-prev-page" class="btn btn-outline-secondary me-2">Prev</button>
                <button id="scene-next-page" class="btn btn-outline-secondary me-2">Next</button>
                <button id="scene-last-page" class="btn btn-outline-secondary">Last</button>
            </div>
            <h4>Status Log</h4>
            <div id="status"></div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.1/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.6.1/toastify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/fontawesome.min.js"></script>
    <script>
    function copyToClipboard(url) {
        navigator.clipboard.writeText(url).then(() => {
        });
    }
    
document.addEventListener('DOMContentLoaded', function() {
    const siteCollectionContainer = document.getElementById('site-collection');
    const sceneCollectionContainer = document.getElementById('scene-collection');
    const backButton = document.getElementById('back-button');
    const sceneTableBody = document.getElementById('scene-table-body');
    const firstPageButton = document.getElementById('site-first-page');
    const prevPageButton = document.getElementById('site-prev-page');
    const nextPageButton = document.getElementById('site-next-page');
    const lastPageButton = document.getElementById('site-last-page');
    const sceneFirstPageButton = document.getElementById('scene-first-page');
    const scenePrevPageButton = document.getElementById('scene-prev-page');
    const sceneNextPageButton = document.getElementById('scene-next-page');
    const sceneLastPageButton = document.getElementById('scene-last-page');
    const setHomeDirectoryButton = document.getElementById('set-home-directory-button');
    const suggestMatchesButton = document.getElementById('suggest-matches-button');
    const matchByUUIDButton = document.getElementById('match-by-uuid-button');
    const bulkUpdateButton = document.getElementById('bulk-update-button');
    const pageSizeSelect = document.getElementById('page-size');
    const homeDirectoryDisplay = document.getElementById('home-directory-display');
    const toggleMatchesButton = document.getElementById('toggle-matches');
    const siteLogoContainer = document.getElementById('site-logo');
    const siteTitleContainer = document.getElementById('site-title');
    const sceneCountDisplay = document.getElementById('scene-count');
    const compareContainer = document.getElementById('compare-container');
    const searchInput = document.getElementById('search-input');
    const sortAscButton = document.getElementById('sort-asc');
    const sortDescButton = document.getElementById('sort-desc');
    const searchStashButton = document.getElementById('search-stash-button');
    const findUrlsButton = document.getElementById('find-urls-button');
    const getAllUrlsButton = document.getElementById('get-all-urls-button');
    const performerSearchInput = document.getElementById('performer-search-input');
    

    let filteredScenes = [];
    let selectedDirectoryPath = '';
    let currentSiteUuid = '';
    let homeDirectory = '';
    let currentPage = 1;
    let sitesPerPage = 12;
    let scenesPerPage = parseInt(pageSizeSelect.value, 10);
    let currentScenes = [];
    let allSites = [];
    let sortColumn = '';
    let sortDirection = 'asc';
    let showOnlyMatches = false;
    let suggestedMatches = [];
    let excludedMatches = new Set();
    let totalPages = 1;
    let totalScenePages = 1;

    setHomeDirectoryButton.addEventListener('click', function() {
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter home directory path';
        input.classList.add('form-control', 'mt-2');
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.classList.add('btn', 'btn-primary', 'mt-2');
        saveButton.addEventListener('click', async () => {
            selectedDirectoryPath = input.value.replace(/\\/g, '/');
            console.log('Selected directory:', selectedDirectoryPath);

            try {
                const response = await fetch('/set_home_directory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ site_uuid: currentSiteUuid, directory: selectedDirectoryPath })
                });

                const result = await response.json();
                if (response.ok) {
                    homeDirectory = selectedDirectoryPath;
                    homeDirectoryDisplay.textContent = homeDirectory;
                    Toastify({
                        text: result.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                    }).showToast();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Error setting home directory:', error);
                Toastify({
                    text: 'Error setting home directory: ' + error.message,
                    duration: 3000,
                    close: true,
                    gravity: "top",
                    position: "right",
                    backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                }).showToast();
            }
        });
        compareContainer.innerHTML = '';
        compareContainer.appendChild(input);
        compareContainer.appendChild(saveButton);
    });
    
    function filterScenesByPerformers() {
            const searchTerm = performerSearchInput.value.toLowerCase();
            if (searchTerm) {
                filteredScenes = currentScenes.filter(scene => {
                    const performers = Array.isArray(scene.performers) ? scene.performers.join(', ') : scene.performers;
                    return performers.toLowerCase().includes(searchTerm);
                });
            } else {
                filteredScenes = [];
            }
            currentPage = 1; // Reset to the first page when filtering
            displayScenes();
            updateScenePaginationButtons();
            updateSearchFieldOutline();
        }

        function updateSearchFieldOutline() {
            if (performerSearchInput.value && filteredScenes.length === 0) {
                performerSearchInput.classList.add('no-results');
            } else {
                performerSearchInput.classList.remove('no-results');
            }
        }

        performerSearchInput.addEventListener('input', debounce(filterScenesByPerformers, 300));

    suggestMatchesButton.addEventListener('click', async function() {
        try {
            const response = await fetch('/suggest_matches', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ site_uuid: currentSiteUuid, tolerance: 95 })
            });
    
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error ${response.status}: ${errorText}`);
            }
    
            suggestedMatches = await response.json();
            const matchedScenes = [];
    
            suggestedMatches.forEach(match => {
                const scene = currentScenes.find(scene => scene.id === match.scene_id);
                if (scene && !matchedScenes.find(s => s.id === scene.id)) {
                    matchedScenes.push(scene);
                    scene.suggested_file = match.suggested_file;
                }
            });
    
            currentScenes = matchedScenes;
            displayScenesWithActions();
            enableBulkUpdate = false;
            bulkUpdateButton.disabled = true;
        } catch (error) {
            console.error('Error suggesting matches:', error);
            Toastify({
                text: 'Error suggesting matches: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        }
    });

    matchByUUIDButton.addEventListener('click', async function() {
        try {
            const response = await fetch('/match_by_uuid', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ site_uuid: currentSiteUuid })
            });
    
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error ${response.status}: ${errorText}`);
            }
    
            const uuidMatches = await response.json();
            console.log('UUID matches:', uuidMatches);
    
            // Clear current table
            sceneTableBody.innerHTML = '';
    
            // Display matched results
            uuidMatches.forEach(match => {
                const scene = currentScenes.find(s => s.id === match.scene_id && s.status !== 'Found');
                if (scene) {
                    const row = document.createElement('tr');
                    row.setAttribute('data-scene-id', scene.id);
                    row.setAttribute('data-foreign-guid', scene.foreign_guid);
    
                    const filePathCellContent = `<i class="fa-regular fa-square-check file-path-icon"></i>${match.suggested_file}`;
                    row.innerHTML = `
                        <td>${scene.title}</td>
                        <td>${scene.date}</td>
                        <td>${formatDuration(scene.duration)}</td>
                        <td>${formatPerformers(scene.performers)}</td>
                        <td>Missing</td>
                        <td data-column="file_path">${filePathCellContent}</td>
                        <td data-column="foreign_guid">${scene.foreign_guid}</td>
                        <td data-column="action" class="action-buttons">
                            <button class="btn btn-success me-2 confirm-match" data-scene-id="${scene.id}" data-file-path="${match.suggested_file}">Confirm</button>
                            <button class="btn btn-danger cancel-match">Cancel</button>
                        </td>
                        <td>${scene.url ? `<a href="${scene.url}" target="_blank">View Scene</a>` : ''}</td>
                    `;
    
                    row.querySelector('.confirm-match').addEventListener('click', async () => {
                        try {
                            const fullFilePath = match.suggested_file;
                            const response = await fetch('/match_scene', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ scene_id: match.scene_id, file_path: fullFilePath })
                            });
    
                            if (!response.ok) {
                                const errorText = await response.text();
                                throw new Error(`Error ${response.status}: ${errorText}`);
                            }
    
                            const result = await response.json();
                            Toastify({
                                text: result.message,
                                duration: 3000,
                                close: true,
                                gravity: "top",
                                position: "right",
                                backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                            }).showToast();
    
                            const confirmedRow = document.querySelector(`tr[data-foreign-guid="${match.scene_id}"]`);
                            if (confirmedRow) {
                                confirmedRow.querySelector('td[data-column="file_path"]').innerHTML = filePathCellContent;
                                confirmedRow.querySelector('td[data-column="file_path"]').classList.add('highlight-found');
                                confirmedRow.querySelector('td[data-column="action"]').innerHTML = '';
                            }
                        } catch (error) {
                            console.error('Error confirming match:', error);
                            Toastify({
                                text: 'Error confirming match: ' + error.message,
                                duration: 3000,
                                close: true,
                                gravity: "top",
                                position: "right",
                                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                            }).showToast();
                        }
                    });
    
                    row.querySelector('.cancel-match').addEventListener('click', () => {
                        const filePathCell = row.querySelector('td[data-column="file_path"]');
                        filePathCell.innerHTML = '';
                        const actionCell = row.querySelector('td[data-column="action"]');
                        actionCell.innerHTML = '';
                    });
    
                    sceneTableBody.appendChild(row);
                }
            });
    
            Toastify({
                text: 'UUID matches found successfully!',
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
            }).showToast();
        } catch (error) {
            console.error('Error matching by UUID:', error);
            Toastify({
                text: 'Error matching by UUID: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        }
    });


    function formatDuration(minutes) {
        if (typeof minutes !== 'number' || isNaN(minutes)) {
            return 'N/A';
        }
        const hrs = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return `${hrs > 0 ? hrs + 'h ' : ''}${mins}m`;
    }
    
    function formatPerformers(performers) {
        return Array.isArray(performers) ? performers.join(', ') : performers;
    }



    function displayScenesWithActions() {
        sceneTableBody.innerHTML = '';
        const sortedScenes = sortScenes(currentScenes);
    
        sortedScenes.forEach(scene => {
            const row = document.createElement('tr');
            row.setAttribute('data-scene-id', scene.id);
            row.setAttribute('data-foreign-guid', scene.foreign_guid);
            const cleanFilePath = scene.suggested_file ? scene.suggested_file.replace(homeDirectory, '') : '';
            row.innerHTML = `
                <td>${scene.title}</td>
                <td>${scene.date}</td>
                <td>${formatDuration(scene.duration)}</td>
                <td>${formatPerformers(scene.performers)}</td>
                <td>${scene.status === 'Found' ? 'Found' : '<i class="fa-solid fa-triangle-exclamation" style="color: red;"></i> Missing'}</td>
                <td data-column="file_path">${scene.local_path ? `<i class="fa-regular fa-square-check file-path-icon"></i>${scene.local_path}` : cleanFilePath}</td>
                <td data-column="foreign_guid">${scene.foreign_guid}</td>
                <td data-column="action" class="action-buttons">
                    <button class="btn btn-success me-2 confirm-match" data-scene-id="${scene.id}" data-file-path="${cleanFilePath}">Confirm</button>
                    <button class="btn btn-danger cancel-match">Cancel</button>
                </td>
            `;
    
            row.querySelector('.confirm-match').addEventListener('click', async () => {
                try {
                    const fullFilePath = `${cleanFilePath}`;
                    const response = await fetch('/match_scene', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            scene_id: scene.id,
                            file_path: fullFilePath,
                            prepend_home_directory: true  // Indicate to prepend home directory
                        })
                    });
    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Error ${response.status}: ${errorText}`);
                    }
    
                    const result = await response.json();
                    Toastify({
                        text: result.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                    }).showToast();
    
                    scene.status = 'Found';
                    scene.local_path = fullFilePath;
    
                    row.querySelector('td[data-column="file_path"]').innerHTML = `<i class="fa-regular fa-square-check file-path-icon"></i>${fullFilePath}`;
                    row.querySelector('td[data-column="file_path"]').classList.add('highlight-found');
                    row.querySelector('td[data-column="action"]').innerHTML = '';
                } catch (error) {
                    console.error('Error confirming match:', error);
                    Toastify({
                        text: 'Error confirming match: ' + error.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                    }).showToast();
                }
            });
    
            row.querySelector('.cancel-match').addEventListener('click', () => {
                const filePathCell = row.querySelector('td[data-column="file_path"]');
                filePathCell.innerHTML = '';
                const actionCell = row.querySelector('td[data-column="action"]');
                actionCell.innerHTML = '';
            });
    
            sceneTableBody.appendChild(row);
        });
    }


    searchStashButton.addEventListener('click', async function() {
        try {
            const response = await fetch('/search_stash_for_matches', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ site_uuid: currentSiteUuid })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error ${response.status}: ${errorText}`);
            }

            const stashMatches = await response.json();
            displayStashMatches(stashMatches);

            Toastify({
                text: 'Stash matches found successfully!',
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
            }).showToast();
        } catch (error) {
            console.error('Error searching stash for matches:', error);
            Toastify({
                text: 'Error searching stash for matches: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        }
    });

    function displayStashMatches(matches) {
        sceneTableBody.innerHTML = ''; // Clear the existing table content

        matches.forEach(match => {
            const row = document.createElement('tr');
            row.setAttribute('data-scene-id', match.scene_id);
            if (match.scene_status === 'Found') return; // Skip already matched scenes
            row.innerHTML = `
                <td>${match.scene_title}</td>
                <td>${match.scene_date}</td>
                <td>${formatDuration(match.scene_duration)}</td>
                <td>${formatPerformers(match.scene_performers)}</td>
                <td>${match.scene_status === 'Found' ? 'Found' : '<i class="fa-solid fa-triangle-exclamation" style="color: red;"></i> Missing'}</td>
                <td>${match.scene_local_path ? match.scene_local_path : match.matched_file_path}</td>
                <td>${match.foreign_guid}</td>
                <td>
                    <button class="btn btn-success confirm-match" data-scene-id="${match.scene_id}" data-file-path="${match.matched_file_path}">Confirm</button>
                </td>
            `;

            row.querySelector('.confirm-match').addEventListener('click', async (e) => {
                const button = e.target;
                const sceneId = button.getAttribute('data-scene-id');
                const filePath = button.getAttribute('data-file-path');

                try {
                    const response = await fetch('/match_scene', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ scene_id: sceneId, file_path: filePath })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Error ${response.status}: ${errorText}`);
                    }

                    const result = await response.json();
                    Toastify({
                        text: result.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                    }).showToast();

                    // Update the row to reflect the confirmed match
                    row.querySelector('td:nth-child(6)').innerText = filePath;
                    row.querySelector('td:nth-child(5)').innerHTML = 'Found';
                    button.remove();
                } catch (error) {
                    console.error('Error confirming match:', error);
                    Toastify({
                        text: 'Error confirming match: ' + error.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                    }).showToast();
                }
            });

            sceneTableBody.appendChild(row);
        });
    }

    bulkUpdateButton.addEventListener('click', async function() {
        let matchesToProcess = [];

        document.querySelectorAll('tr').forEach(row => {
            const confirmButton = row.querySelector('.confirm-match');
            if (confirmButton) {
                const sceneId = confirmButton.getAttribute('data-scene-id');
                const filePath = confirmButton.getAttribute('data-file-path');
                matchesToProcess.push({
                    scene_id: sceneId,
                    file_path: filePath
                });
            }
        });

        for (const match of matchesToProcess) {
            try {
                const response = await fetch('/match_scene', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ scene_id: match.scene_id, file_path: match.file_path })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error ${response.status}: ${errorText}`);
                }

                const result = await response.json();

                const scene = currentScenes.find(s => s.id == match.scene_id);
                if (scene) {
                    scene.status = 'Found';
                    scene.local_path = match.file_path;
                }
            } catch (error) {
                console.error('Error confirming match:', error);
                Toastify({
                    text: 'Error confirming match: ' + error.message,
                    duration: 3000,
                    close: true,
                    gravity: "top",
                    position: "right",
                    backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                }).showToast();
            }
        }
        displayScenes();
        Toastify({
            text: 'All matches confirmed!',
            duration: 3000,
            close: true,
            gravity: "top",
            position: "right",
            backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
        }).showToast();
    });

    function enableBulkUpdateButton() {
        enableBulkUpdate = true;
        bulkUpdateButton.disabled = false;
    }

    async function fetchCollection() {
        try {
            const response = await fetch('/collection_data?per_page=1000'); // Fetch all data at once
            if (!response.ok) {
                throw new Error(`Error ${response.status}: ${await response.text()}`);
            }
            const siteCollection = await response.json();
            console.log('Collection fetched:', siteCollection);

            allSites = siteCollection.collection_data;
            totalPages = Math.ceil(allSites.length / sitesPerPage);
            displayCollection();
        } catch (error) {
            console.error('Error fetching collection:', error);
            Toastify({
                text: 'Error fetching collection: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        }
    }

    function displayCollection(page = 1, filteredCollection = null) {
        siteCollectionContainer.innerHTML = '';

        const collectionData = filteredCollection || allSites;
        totalPages = Math.ceil(collectionData.length / sitesPerPage);
        currentPage = page;

        const paginatedSites = collectionData.slice((page - 1) * sitesPerPage, page * sitesPerPage);

        paginatedSites.forEach(item => {
            const totalScenes = item.total_scenes;
            const collectedScenes = item.collected_scenes;
            const progressPercentage = totalScenes > 0 ? (collectedScenes / totalScenes) * 100 : 0;
            const logoUrl = item.site.logo;

            const siteCard = document.createElement('div');
            siteCard.classList.add('col-md-4');
            siteCard.innerHTML = `
                <div class="card h-100 site-card ${logoUrl ? '' : 'no-logo'}">
                    <div class="card-body">
                        <div class="d-flex flex-column align-items-center">
                            ${logoUrl ? 
                                `<img src="${logoUrl}" class="max-h-24 object-contain mb-3" alt="${item.site.name}" onerror="this.onerror=null;this.src='default_image.png';">` : 
                                ''}
                            <h2 class="site-title">${item.site.name}</h2>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-bar-inner" style="width: ${progressPercentage}%;"></div>
                            <div class="progress-bar-text">${collectedScenes} / ${totalScenes}</div>
                        </div>
                        <p class="site-title">${item.site.name}</p>
                        <button class="btn btn-danger remove-site-button" data-site-uuid="${item.site.uuid}">Remove</button>
                    </div>
                </div>
            `;

            siteCard.addEventListener('click', () => {
                currentSiteUuid = item.site.uuid;
                homeDirectory = item.site.home_directory || '';
                homeDirectoryDisplay.textContent = homeDirectory;
                siteLogoContainer.innerHTML = logoUrl ? `<img src="${logoUrl}" alt="${item.site.name}">` : '';
                siteTitleContainer.innerText = item.site.name;
                siteCollectionContainer.classList.add('d-none');
                sceneCollectionContainer.classList.remove('d-none');
                showScenesForSite(item.scenes);
            });

            siteCollectionContainer.appendChild(siteCard);
        });

        document.querySelectorAll('.remove-site-button').forEach(button => {
            button.addEventListener('click', async (e) => {
                e.stopPropagation();
                const siteUuid = e.target.getAttribute('data-site-uuid');
                await removeSiteFromCollection(siteUuid);
            });
        });

        updatePaginationButtons();
    }

    async function removeSiteFromCollection(siteUuid) {
        const response = await fetch(`/remove_site/${siteUuid}`, { method: 'DELETE' });
        const data = await response.json();
        console.log('Site removed:', data);
        Toastify({
            text: 'Site has been removed from your collection.',
            duration: 3000,
            close: true,
            gravity: "top",
            position: "right",
            backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
        }).showToast();
        fetchCollection();
    }

    function showScenesForSite(scenes) {
        currentScenes = scenes.map(scene => {
            return {
                ...scene,
                status: scene.status || 'Missing'
            };
        });
        currentScenes = sortScenes(currentScenes, 'title', 'asc');
        currentPage = 1;
        totalScenePages = Math.ceil(currentScenes.length / scenesPerPage);
        updateSceneCount();
        displayScenes();
        updatePaginationButtons();
        updateScenePaginationButtons();
    }

    function displayScenes() {
            const scenesToDisplay = filteredScenes.length > 0 ? filteredScenes : currentScenes;
            sceneTableBody.innerHTML = '';
            const filteredScenesToShow = showOnlyMatches ? scenesToDisplay.filter(scene => scene.status === 'Found') : scenesToDisplay;
            const sortedScenes = sortScenes(filteredScenesToShow);
            const scenesToShow = sortedScenes.slice((currentPage - 1) * scenesPerPage, currentPage * scenesPerPage);

            scenesToShow.forEach(scene => {
                const row = document.createElement('tr');
                row.setAttribute('data-scene-id', scene.id);
                row.setAttribute('data-foreign-guid', scene.foreign_guid);
                row.innerHTML = `
                    <td>${scene.title}</td>
                    <td>${scene.date}</td>
                    <td>${formatDuration(scene.duration)}</td>
                    <td>${formatPerformers(scene.performers)}</td>
                    <td>${scene.status === 'Found' ? 'Found' : '<i class="fa-solid fa-triangle-exclamation" style="color: red;"></i> Missing'}</td>
                    <td data-column="file_path">${scene.local_path ? `<i class="fa-regular fa-square-check file-path-icon"></i>${scene.local_path}` : ''}</td>
                    <td data-column="foreign_guid">
                    ${scene.foreign_guid ? `<a href="https://theporndb.net/scenes/${scene.foreign_guid}" target="_blank">${scene.foreign_guid}</a>` : ''}
                    </td>
                    <td><button class="btn btn-primary match-button">Match</button></td>
                    <td>
                        ${scene.url ? `
                            <a href="${scene.url}" target="_blank">View Scene</a>
                            <img src="{{ url_for('static', filename='Jdownloader.png') }}" class="jdownloader-icon" data-url="${scene.url}" title="Copy to JDownloader" onclick="copyToClipboard('${scene.url}')">
                        ` : `
                            <button class="btn btn-info find-url-button" data-scene-id="${scene.foreign_guid}">Find URL</button>
                        `}
                    </td>
                `;
                row.querySelector('.match-button').addEventListener('click', () => handleMatchButtonClick(scene));

                const findUrlButton = row.querySelector('.find-url-button');
                if (findUrlButton) {
                    findUrlButton.addEventListener('click', () => findSceneUrl(scene.foreign_guid));
                }

                sceneTableBody.appendChild(row);
            });
            updateScenePaginationButtons();
        }

    toggleMatchesButton.addEventListener('click', () => {
        showOnlyMatches = !showOnlyMatches;
        displayScenes();
    });

    function sortScenes(scenes) {
            if (sortColumn) {
                return scenes.sort((a, b) => {
                    let valA = a[sortColumn];
                    let valB = b[sortColumn];

                    if (typeof valA === 'string') {
                        valA = valA.toLowerCase();
                    }
                    if (typeof valB === 'string') {
                        valB = valB.toLowerCase();
                    }

                    if (valA < valB) {
                        return sortDirection === 'asc' ? -1 : 1;
                    }
                    if (valA > valB) {
                        return sortDirection === 'asc' ? 1 : -1;
                    }
                    return 0;
                });
            }
            return scenes;
        }

    function updateSceneCount() {
        const totalScenes = currentScenes.length;
        const matchedScenes = currentScenes.filter(scene => scene.status === 'Found').length;
        sceneCountDisplay.textContent = `${matchedScenes}/${totalScenes} scenes in collection`;
    }

    document.querySelectorAll('th[data-column]').forEach(th => {
        th.addEventListener('click', () => {
            const column = th.getAttribute('data-column');
            if (column) {
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                displayScenes();
            }
        });
    });

    pageSizeSelect.addEventListener('change', () => {
        scenesPerPage = parseInt(pageSizeSelect.value, 10);
        totalScenePages = Math.ceil(currentScenes.length / scenesPerPage);
        displayScenes();
        updateScenePaginationButtons();
    });

    function formatDuration(minutes) {
        if (typeof minutes !== 'number' || isNaN(minutes)) {
            return 'N/A';
        }
        const hrs = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return `${hrs > 0 ? hrs + 'h ' : ''}${mins}m`;
    }

    function formatPerformers(performers) {
        return Array.isArray(performers) ? performers.join(', ') : performers;
    }

    async function handleMatchButtonClick(scene) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.mp4';
        input.onchange = async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    const filePath = homeDirectory ? `${homeDirectory}/${file.webkitRelativePath || file.name}` : file.webkitRelativePath || file.name;
                    const response = await fetch('/match_scene', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ scene_id: scene.id, file_path: filePath })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Error ${response.status}: ${errorText}`);
                    }

                    const result = await response.json();

                    scene.status = 'Found';
                    scene.local_path = filePath;

                    Toastify({
                        text: result.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                    }).showToast();
                    displayScenes();
                    enableBulkUpdateButton();
                } catch (error) {
                    console.error('Error matching scene:', error);
                    Toastify({
                        text: 'Error matching scene: ' + error.message,
                        duration: 3000,
                        close: true,
                        gravity: "top",
                        position: "right",
                        backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                    }).showToast();
                }
            }
        };
        input.click();
    }

    function updatePaginationButtons() {
        firstPageButton.disabled = currentPage === 1;
        prevPageButton.disabled = currentPage === 1;
        nextPageButton.disabled = currentPage === totalPages;
        lastPageButton.disabled = currentPage === totalPages;

        firstPageButton.classList.toggle('disabled', currentPage === 1);
        prevPageButton.classList.toggle('disabled', currentPage === 1);
        nextPageButton.classList.toggle('disabled', currentPage === totalPages);
        lastPageButton.classList.toggle('disabled', currentPage === totalPages);
    }

    function updateScenePaginationButtons() {
            const scenesToDisplay = filteredScenes.length > 0 ? filteredScenes : currentScenes;
            const totalScenePages = Math.ceil(scenesToDisplay.length / scenesPerPage);

            sceneFirstPageButton.disabled = currentPage === 1;
            scenePrevPageButton.disabled = currentPage === 1;
            sceneNextPageButton.disabled = currentPage === totalScenePages;
            sceneLastPageButton.disabled = currentPage === totalScenePages;

            sceneFirstPageButton.classList.toggle('disabled', currentPage === 1);
            scenePrevPageButton.classList.toggle('disabled', currentPage === 1);
            sceneNextPageButton.classList.toggle('disabled', currentPage === totalScenePages);
            sceneLastPageButton.classList.toggle('disabled', currentPage === totalScenePages);
        }

    firstPageButton.addEventListener('click', () => {
        currentPage = 1;
        displayCollection(currentPage);
    });

    prevPageButton.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            displayCollection(currentPage);
        }
    });

    nextPageButton.addEventListener('click', () => {
        if (currentPage < totalPages) {
            currentPage++;
            displayCollection(currentPage);
        }
    });

    lastPageButton.addEventListener('click', () => {
        currentPage = totalPages;
        displayCollection(currentPage);
    });

    sceneFirstPageButton.addEventListener('click', () => {
        currentPage = 1;
        displayScenes();
    });

    scenePrevPageButton.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            displayScenes();
        }
    });

    sceneNextPageButton.addEventListener('click', () => {
        if (currentPage < totalScenePages) {
            currentPage++;
            displayScenes();
        }
    });

    sceneLastPageButton.addEventListener('click', () => {
        currentPage = totalScenePages;
        displayScenes();
    });

    backButton.addEventListener('click', () => {
        siteCollectionContainer.classList.remove('d-none');
        sceneCollectionContainer.classList.add('d-none');
    });

    searchInput.addEventListener('input', debounce(() => {
        const searchTerm = searchInput.value.toLowerCase();
        const filteredCollection = allSites.filter(item => item.site.name.toLowerCase().includes(searchTerm));
        displayCollection(1, filteredCollection);
    }, 300));

    sortAscButton.addEventListener('click', () => {
        sortDirection = 'asc';
        allSites.sort((a, b) => a.site.name.localeCompare(b.site.name));
        displayCollection(currentPage);
    });

    sortDescButton.addEventListener('click', () => {
        sortDirection = 'desc';
        allSites.sort((a, b) => b.site.name.localeCompare(a.site.name));
        displayCollection(currentPage);
    });

    fetchCollection();

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    }

    async function findSceneUrl(sceneUuid) {
        console.log('Finding URL for scene UUID:', sceneUuid); // Logging the scene UUID
        try {
            const response = await fetch('/get_scene_details', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ scene_uuid: sceneUuid })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log('Result from /get_scene_details:', result); // Logging the result
            const sceneUrl = result.url;
            const sceneRow = document.querySelector(`tr[data-foreign-guid="${sceneUuid}"]`);
            if (sceneRow && sceneUrl) {
                sceneRow.querySelector('td:last-child').innerHTML = `
                    <a href="${sceneUrl}" target="_blank">View Scene</a>
                    <img src="{{ url_for('static', filename='Jdownloader.png') }}" class="jdownloader-icon" data-url="${sceneUrl}" title="Copy to JDownloader" onclick="copyToClipboard('${sceneUrl}')">
                `;
            }

            // Save the URL to the local database
            await saveSceneUrl(sceneUuid, sceneUrl);

            return true;
        } catch (error) {
            console.error('Error finding scene URL:', error);
            Toastify({
                text: 'Error finding scene URL: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
            return false;
        }
    }

    async function saveSceneUrl(sceneUuid, url) {
        try {
            const response = await fetch('/save_scene_url', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ scene_uuid: sceneUuid, url: url })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Error ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log('Scene URL saved successfully:', result);
        } catch (error) {
            console.error('Error saving scene URL:', error);
        }
    }

    let stopGetAllUrls = false;

    getAllUrlsButton.addEventListener('click', async function() {
        const currentState = getAllUrlsButton.getAttribute('data-state');
        if (currentState === 'start') {
            stopGetAllUrls = false;
            getAllUrlsButton.setAttribute('data-state', 'stop');
            getAllUrlsButton.innerHTML = '<i class="fa fa-stop"></i> Stop';
            getAllUrlsButton.classList.remove('btn-primary');
            getAllUrlsButton.classList.add('btn-danger');
            await getAllUrls();
        } else {
            stopGetAllUrls = true;
            await stopGetAllUrlsProcess();
            getAllUrlsButton.setAttribute('data-state', 'start');
            getAllUrlsButton.innerHTML = '<i class="fa fa-play"></i> Get All Scene URLs';
            getAllUrlsButton.classList.remove('btn-danger');
            getAllUrlsButton.classList.add('btn-primary');
        }
    });

    async function getAllUrls() {
        let urlsAdded = 0;

        try {
            for (const scene of currentScenes) {
                if (stopGetAllUrls) {
                    console.log('Stopping process as requested');
                    break;
                }
                if (!scene.url) {
                    console.log('Finding URL for scene:', scene.foreign_guid);
                    const urlFound = await findSceneUrl(scene.foreign_guid);
                    if (urlFound) {
                        urlsAdded++;
                    }
                }
            }

            Toastify({
                text: `URLs added for ${urlsAdded} scenes!`,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
            }).showToast();
        } catch (error) {
            console.error('Error finding URLs for all scenes:', error);
            Toastify({
                text: 'Error finding URLs for all scenes: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        } finally {
            // Reset button state when the process is complete or stopped
            getAllUrlsButton.setAttribute('data-state', 'start');
            getAllUrlsButton.innerHTML = '<i class="fa fa-play"></i> Get All Scene URLs';
            getAllUrlsButton.classList.remove('btn-danger');
            getAllUrlsButton.classList.add('btn-primary');
        }
    }

    async function stopGetAllUrlsProcess() {
        try {
            const response = await fetch('/stop_get_all_urls', { method: 'POST' });
            if (!response.ok) {
                throw new Error(`Error stopping the process: ${response.statusText}`);
            }
            const result = await response.json();
            Toastify({
                text: result.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
            }).showToast();
        } catch (error) {
            console.error('Error stopping the process:', error);
            Toastify({
                text: 'Error stopping the process: ' + error.message,
                duration: 3000,
                close: true,
                gravity: "top",
                position: "right",
                backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
            }).showToast();
        } finally {
            // Ensure the button is reset to play state even if there's an error
            getAllUrlsButton.setAttribute('data-state', 'start');
            getAllUrlsButton.innerHTML = '<i class="fa fa-play"></i> Get All Scene URLs';
            getAllUrlsButton.classList.remove('btn-danger');
            getAllUrlsButton.classList.add('btn-primary');
        }
    }

    // Event listener to copy URL to clipboard
    document.addEventListener('click', function(e) {
        if (e.target && e.target.classList.contains('jdownloader-icon')) {
            const url = e.target.getAttribute('data-url');
            navigator.clipboard.writeText(url).then(() => {
                Toastify({
                    text: 'URL copied to clipboard!',
                    duration: 3000,
                    close: true,
                    gravity: "top",
                    position: "right",
                    backgroundColor: "linear-gradient(to right, #00b09b, #96c93d)"
                }).showToast();
            }).catch(err => {
                console.error('Error copying URL to clipboard:', err);
                Toastify({
                    text: 'Error copying URL to clipboard: ' + err.message,
                    duration: 3000,
                    close: true,
                    gravity: "top",
                    position: "right",
                    backgroundColor: "linear-gradient(to right, #ff5f6d, #ffc371)"
                }).showToast();
            });
        }
    });
    fetchCollection();
});
</script>
<script>
        function startSSE() {
            const eventSource = new EventSource('/log_stream');
            
            eventSource.addEventListener('message', function(event) {
                const newMessage = document.createElement('div');
                newMessage.textContent = event.data;
                const statusDiv = document.getElementById("status");
                statusDiv.insertBefore(newMessage, statusDiv.firstChild);
                if (statusDiv.children.length > 3) {
                    statusDiv.removeChild(statusDiv.lastChild);
                }
            });

            eventSource.addEventListener('error', function(event) {
                const newMessage = document.createElement('div');
                newMessage.textContent = `Error: ${event.data}`;
                const statusDiv = document.getElementById("status");
                statusDiv.insertBefore(newMessage, statusDiv.firstChild);
                if (statusDiv.children.length > 3) {
                    statusDiv.removeChild(statusDiv.lastChild);
                }
                eventSource.close();
            });
        }

        document.addEventListener("DOMContentLoaded", function() {
            startSSE();
        });
</script>
</body>
</html>
